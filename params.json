{"name":"hapi-coap-listener","tagline":"CoAP listener for Hapi","body":"# hapi-coap-listener [![Build Status](https://travis-ci.org/boneskull/hapi-coap-listener.svg?branch=master)](https://travis-ci.org/boneskull/hapi-coap-listener)\r\n\r\n> CoAP listener for Hapi\r\n\r\n## Install\r\n\r\n```shell\r\n$ npm install hapi-coap-listener\r\n```\r\n\r\n## Requirements\r\n\r\n- [io.js](https://iojs.org) >= v2.0.1\r\n- [Hapi](http://hapijs.com) >= v8.x\r\n\r\n## Usage\r\n\r\n```js\r\n// app.js\r\n\r\nlet Hapi = require('hapi');\r\n\r\n// add your own defaults here\r\nlet server = new Hapi.Server({\r\n  connections: {\r\n    coap: {\r\n      host: 'localhost'\r\n    }\r\n  }\r\n});\r\n\r\n// connection props generated for you include: uri, listener, autoListen (true),\r\n// and tls (false).  \r\nlet options = require('hapi-coap-listener')(server, {\r\n  port: 5693, // this is the port of the CoAP server\r\n  labels: ['coap', 'on-a-rope'] // default label is 'coap'\r\n  sock: null // define a socket path here if you wish; otherwise one is created\r\n});\r\n\r\nserver.connection(options);\r\n\r\nserver.route({\r\n  method: 'GET',\r\n  path: '/',\r\n  handler: function(req, reply) {\r\n    reply('Hello world!');\r\n  })\r\n});\r\n\r\nserver.start(function(err) {\r\n  if (err) {\r\n    throw new Error(err);\r\n  }\r\n  console.log(`Hapi listening on ${server.info.uri}`); \r\n});\r\n```\r\n\r\nTry it with [coap-cli](https://www.npmjs.com/package/coap-cli):\r\n\r\n```sh\r\n$ node /path/to/app.js # start CoAP server\r\n```\r\n\r\nIn another shell:\r\n\r\n```sh\r\n$ npm install -g coap-cli\r\n$ coap get coap://localhost/\r\n```\r\n\r\n## The How's and Why's\r\n\r\n[CoAP](https://en.wikipedia.org/wiki/Constrained_Application_Protocol), at first glance, is fairly similar to HTTP, with its notion of \"options\" (\"headers\"), URL paths and modes.  Seems like a great fit for \"web server\" frameworks, doesn't it?\r\n\r\nWell, yes and no.\r\n \r\nThe main problem arises from the fact that CoAP is bound to UDP instead of TCP.  This means it has no notion of a *connection*.  Hapi, and just about any other web server framework you will find, assumes you are listening with an HTTP server for HTTP traffic (if they didn't, they'd suck).  So, a web server will listen for the `connection` event to determine how to handle requests and responses from a client.  \r\n\r\nWithout a connection, you can't run a web server.  CoAP has no connections.  This looks grim.\r\n\r\nBut a cool thing about Hapi (and other frameworks as well, but I like Hapi) is that it gives you some wiggle room.  You can hand it a generic TCP server (think `net.Server()`) for a listener (see [`server.connection()`](http://hapijs.com/api#serverconnectionoptions)).  Even better, it doesn't need to bind to a port of a network interface, and can bind to a UNIX socket (or Windows pipe).  Hapi will listen on that TCP server for HTTP requests and reply with HTTP responses--even if it's listening on some file in `/tmp/`.  Furthermore, it streamlines \"faking\" connections with [`server.inject()`](http://hapijs.com/api#serverinjectoptions-callback).\r\n\r\nThis module gives Hapi a dummy TCP server acting as a proxy to a CoAP server.  Rough flow:\r\n\r\n1. A client requests `coap://host:port/some/route`\r\n2. CoAP server injects the request into the TCP server\r\n3. Hapi dispatches the request and any routes, handlers, etc. are invoked\r\n4. Upon reply, the callback function CoAPifies* the response object, then issues a proper response to the client\r\n\r\nWhat happened to the UNIX socket?  Nothing.  We don't use it.  Then why not just forget about the TCP server, and inject into a HTTP listener?  Loose coupling, mainly--a separate connection allows you to make CoAP- or HTTP-only routes, configuration, or runtime data.  Indeed, as-of-yet unimplemented features ([see below](#roadmap)) may further necessitate the schism.  Also, this assumes you're running a HTTP server.\r\n\r\n*CoAPification: translating an HTTP request or response into a CoAP request or response, respectively\r\n\r\n## Roadmap\r\n\r\nCurrently, this module **does not** support anything beyond basic requests and responses.  So:\r\n\r\n1.  [Observe mode](https://github.com/boneskull/hapi-coap-listener/issues/2) (multiple responses per request)\r\n2.  [Multicast](https://github.com/boneskull/hapi-coap-listener/issues/3) (possible?  no idea)\r\n3.  [DTLS](https://github.com/boneskull/hapi-coap-listener/issues/4) (probably impossible without monkeypatching Hapi)\r\n4.  [Blockwise transfers](https://github.com/boneskull/hapi-coap-listener/issues/5) (I have no idea what this even is)\r\n\r\n## License\r\n\r\nÂ© 2015 [Christopher Hiller](https://boneskull.com).  Licensed MIT.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}